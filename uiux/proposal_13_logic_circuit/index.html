<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galileo Arena - Proposal 13: Logic Circuit</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Roboto+Mono&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #F0F2F5;
            font-family: 'Inter', sans-serif;
            color: #333;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 40px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.8);
            pointer-events: auto;
            transition: transform 0.3s ease;
        }

        .glass-panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 1.5rem;
            margin: 0 0 5px 0;
            color: #111;
        }

        p {
            margin: 0;
            font-size: 0.9rem;
            color: #666;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        .control-btn {
            background: #fff;
            color: #007AFF;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0, 122, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: #007AFF;
            color: #fff;
            transform: scale(1.05);
        }

        #verdict-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 50px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #verdict-modal.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .loader {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div id="ui-overlay">
        <div class="glass-panel">
            <h1>Architecture: Logic Circuit</h1>
            <p>Processing core arguments...</p>
            <div class="stat-row">
                <span>Load:</span>
                <span id="load-val">12%</span>
            </div>
            <div class="stat-row">
                <span>Nodes:</span>
                <span>Active</span>
            </div>
        </div>

        <div class="glass-panel" style="text-align: right;">
            <h1>Judge Node</h1>
            <p>Awaiting Consensus</p>
            <div class="stat-row" style="justify-content: flex-end; gap: 10px;">
                <span>Status:</span>
                <span id="judge-status" style="color: #007AFF;">IDLE</span>
            </div>
        </div>
    </div>

    <div id="controls">
        <button class="control-btn" onclick="startProcess()">Run Simulation</button>
    </div>

    <div id="verdict-modal">
        <h1 style="font-size: 2rem; margin-bottom: 20px;">Logic Verified</h1>
        <p>The core has reached a unanimous decision.</p>
        <div class="loader" id="loader"></div>
        <button class="control-btn" style="margin-top: 30px;" onclick="closeModal()">Dismiss</button>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- THREE JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF0F2F5);
        scene.fog = new THREE.Fog(0xF0F2F5, 20, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;
        camera.position.y = 20;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- OBJECTS ---

        // Floor
        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const planeMat = new THREE.ShadowMaterial({ opacity: 0.1 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // CPU (Judge) - Center
        const cpuGeo = new THREE.DodecahedronGeometry(5);
        const cpuMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.1,
            clearcoat: 1.0,
            transparent: true,
            opacity: 0.9
        });
        const cpu = new THREE.Mesh(cpuGeo, cpuMat);
        cpu.castShadow = true;
        cpu.position.y = 8;
        scene.add(cpu);

        // CPU Core (Inner glow)
        const coreGeo = new THREE.DodecahedronGeometry(3);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x007AFF, wireframe: true });
        const core = new THREE.Mesh(coreGeo, coreMat);
        cpu.add(core);

        // Nodes (Robots)
        const nodes = [];
        const nodeCount = 5;
        const radius = 20;

        for (let i = 0; i < nodeCount; i++) {
            const angle = (i / nodeCount) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const geometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.1
            });
            const node = new THREE.Mesh(geometry, material);
            node.position.set(x, 4, z);
            node.castShadow = true;

            // Orbit ring for node
            const ringGeo = new THREE.TorusGeometry(3, 0.05, 16, 50);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x007AFF, transparent: true, opacity: 0.5 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            node.add(ring);

            scene.add(node);
            nodes.push({ mesh: node, basePos: { x, y: 4, z }, active: false });
        }

        // Connecting Lines
        const lines = [];
        const lineMat = new THREE.LineBasicMaterial({ color: 0x007AFF, transparent: true, opacity: 0.2 });
        nodes.forEach(node => {
            const points = [node.mesh.position, cpu.position];
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geo, lineMat.clone()); // Clone material for individual opacity control
            scene.add(line);
            lines.push(line);
        });

        // --- ANIMATION FRAME ---
        let time = 0;
        let simulating = false;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Rotate CPU
            cpu.rotation.y += 0.005;
            cpu.position.y = 8 + Math.sin(time) * 0.5;
            core.rotation.z -= 0.01;

            // Animate Nodes
            nodes.forEach((node, i) => {
                node.mesh.position.y = node.basePos.y + Math.cos(time + i) * 1;

                if (simulating) {
                    // Excitement
                    node.mesh.scale.setScalar(1 + Math.sin(time * 5 + i) * 0.1);
                    lines[i].material.opacity = 0.8 + Math.sin(time * 10) * 0.2;
                    lines[i].material.linewidth = 2; // Note: linewidth doesn't work on all browsers implementation of WebGL
                } else {
                    node.mesh.scale.setScalar(1);
                    lines[i].material.opacity = 0.2;
                }

                // Update lines
                const positions = lines[i].geometry.attributes.position.array;
                positions[0] = node.mesh.position.x;
                positions[1] = node.mesh.position.y;
                positions[2] = node.mesh.position.z;
                positions[3] = cpu.position.x;
                positions[4] = cpu.position.y;
                positions[5] = cpu.position.z;
                lines[i].geometry.attributes.position.needsUpdate = true;
            });

            if (simulating) {
                // Judge color shift
                core.material.color.setHSL((time % 1), 1, 0.5);
            } else {
                core.material.color.setHex(0x007AFF);
            }

            renderer.render(scene, camera);
        }
        animate();

        // --- LOGIC ---
        function startProcess() {
            if (simulating) return;
            simulating = true;
            document.getElementById('judge-status').innerText = "CALCULATING";
            document.getElementById('load-val').innerText = "99%";

            // Random pulses
            const duration = 3000;

            setTimeout(() => {
                simulating = false;
                document.getElementById('judge-status').innerText = "VERDICT READY";
                document.getElementById('load-val').innerText = "12%";
                showModal();
            }, duration);
        }

        function showModal() {
            document.getElementById('verdict-modal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('verdict-modal').classList.remove('active');
            document.getElementById('judge-status').innerText = "IDLE";
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>