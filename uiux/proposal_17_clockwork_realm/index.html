<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galileo Arena - Proposal 17: Clockwork Realm</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rye&family=Courier+Prime:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #e0e0e0;
            font-family: 'Courier Prime', monospace;
            color: #3e3e3e;
        }

        /* Sepia Overlay */
        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(100, 80, 50, 0.1);
            pointer-events: none;
            mix-blend-mode: multiply;
        }

        #ui-plate {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: linear-gradient(to bottom, #d4af37, #cd7f32);
            border-top: 5px solid #8b5a2b;
            box-shadow: 0 -10px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 50px;
            z-index: 10;
        }

        /* Rivets */
        #ui-plate::before,
        #ui-plate::after {
            content: '';
            position: absolute;
            top: 10px;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle at 30% 30%, #fff, #555);
            border-radius: 50%;
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        #ui-plate::before {
            left: 20px;
        }

        #ui-plate::after {
            right: 20px;
        }

        h1 {
            font-family: 'Rye', serif;
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 3rem;
            color: #3e3e3e;
            text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.5);
            margin: 0;
            z-index: 10;
        }

        .brass-btn {
            background: radial-gradient(circle, #f0e68c, #d4af37);
            border: 4px solid #8b5a2b;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            color: #3e3e3e;
            font-family: 'Rye', serif;
            font-size: 0.8rem;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
            transition: transform 0.1s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .brass-btn:active {
            transform: translateY(4px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #fff8dc;
            padding: 20px;
            border: 2px solid #8b5a2b;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2);
            width: 200px;
            z-index: 10;
            transform: rotate(-1deg);
        }

        .gauge-container {
            width: 100%;
            height: 10px;
            background: #ccc;
            border: 1px solid #555;
            margin-top: 5px;
            position: relative;
        }

        .gauge-fill {
            height: 100%;
            background: #8b0000;
            width: 10%;
            transition: width 0.5s;
        }
    </style>
</head>

<body>

    <h1>The Grand Mechanism</h1>

    <div id="info-panel">
        <div><strong>PRESSURE</strong></div>
        <div class="gauge-container">
            <div class="gauge-fill" id="pressure-bar"></div>
        </div>
        <br>
        <div><strong>RPM</strong></div>
        <div class="gauge-container">
            <div class="gauge-fill" id="rpm-bar" style="background: #cd7f32"></div>
        </div>
    </div>

    <div id="ui-plate">
        <button class="brass-btn" onclick="increasePressure()">Grind Gears</button>
        <button class="brass-btn" onclick="lubricate()">Oil Machine</button>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- THREE JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        // Steam fog
        scene.fog = new THREE.FogExp2(0xe0e0e0, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffaa00, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- GEAR GENERATION ---

        function createGear(radius, teeth, color, x, y, z) {
            const group = new THREE.Group();

            // Gear Body
            const cylinderGeo = new THREE.CylinderGeometry(radius, radius, 2, 32);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.6,
                roughness: 0.4
            });
            const body = new THREE.Mesh(cylinderGeo, material);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            group.add(body);

            // Teeth
            const toothGeo = new THREE.BoxGeometry(1.5, 1, 2);
            for (let i = 0; i < teeth; i++) {
                const angle = (i / teeth) * Math.PI * 2;
                const tooth = new THREE.Mesh(toothGeo, material);
                tooth.position.x = Math.cos(angle) * (radius + 0.5);
                tooth.position.y = Math.sin(angle) * (radius + 0.5);
                tooth.rotation.z = angle;
                group.add(tooth);
            }

            // Axle
            const axleGeo = new THREE.CylinderGeometry(1, 1, 4, 16);
            const axleMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const axle = new THREE.Mesh(axleGeo, axleMat);
            axle.rotation.x = Math.PI / 2;
            group.add(axle);

            group.position.set(x, y, z);
            scene.add(group);
            return group;
        }

        // Create a system of gears
        const gears = [];

        // Main Drive Gear (Center)
        const mainGear = createGear(5, 12, 0xd4af37, 0, 0, 0);
        gears.push({ mesh: mainGear, speed: 0.01, dir: 1 });

        // Satellite Gears
        const sat1 = createGear(3, 8, 0xcd7f32, 9, 0, 0);
        gears.push({ mesh: sat1, speed: 0.016, dir: -1 }); // Inverse rotation

        const sat2 = createGear(3, 8, 0xcd7f32, -9, 0, 0);
        gears.push({ mesh: sat2, speed: 0.016, dir: -1 });

        const sat3 = createGear(4, 10, 0x8b5a2b, 0, 10, 0);
        gears.push({ mesh: sat3, speed: 0.0125, dir: -1 });

        const sat4 = createGear(2, 6, 0x555555, 6, 8, -5);
        gears.push({ mesh: sat4, speed: 0.025, dir: 1 });

        // --- BACKGROUND PIPES ---
        // Just visual clutter
        const pipeGeo = new THREE.CylinderGeometry(1, 1, 100, 16);
        const pipeMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const pipe1 = new THREE.Mesh(pipeGeo, pipeMat);
        pipe1.position.z = -20;
        pipe1.rotation.z = Math.PI / 4;
        scene.add(pipe1);

        // --- ANIMATION ---

        let pressure = 0; // Defines "grinding" or wobble
        let friction = 0;

        function animate() {
            requestAnimationFrame(animate);

            gears.forEach(g => {
                // Rotation
                const wobble = Math.sin(Date.now() * 0.01) * pressure * 0.05;
                g.mesh.rotation.z += g.speed * g.dir * (1 + friction);

                // Shake if high pressure
                if (pressure > 0.5) {
                    g.mesh.position.x += (Math.random() - 0.5) * 0.1;
                    g.mesh.position.y += (Math.random() - 0.5) * 0.1;
                }
            });

            // Decay pressure
            if (pressure > 0) pressure *= 0.98;
            if (friction > 0) friction *= 0.99;
            else friction = 0;

            // Camera float
            camera.position.x = Math.sin(Date.now() * 0.0005) * 5;
            camera.lookAt(0, 0, 0);

            // Update UI
            document.getElementById('pressure-bar').style.width = (pressure * 100) + "%";
            document.getElementById('rpm-bar').style.width = ((1 + friction) * 20) + "%";

            renderer.render(scene, camera);
        }
        animate();

        // --- INTERACTION ---

        function increasePressure() {
            pressure = 1.0;
            friction = -0.5; // Slow down/Grind

            // Change color momentarily
            gears.forEach(g => {
                g.mesh.traverse((child) => {
                    if (child.isMesh && child.userData.originalColor == undefined) {
                        child.userData.originalColor = child.material.color.getHex();
                    }
                    if (child.isMesh) child.material.color.setHex(0x8b0000);
                });
            });

            setTimeout(() => {
                gears.forEach(g => {
                    g.mesh.traverse((child) => {
                        if (child.isMesh && child.userData.originalColor != undefined) {
                            child.material.color.setHex(child.userData.originalColor);
                        }
                    });
                });
            }, 500);
        }

        function lubricate() {
            friction = 2.0; // Speed up smoothly
            pressure = 0;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>